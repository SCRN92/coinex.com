// Generated by CoffeeScript 2.5.1
(function() {
  var CError, Coinex, HOST, MD5, Path, Property, Request, URL, URLSearchParams, V1, arrayFloat, dataFloat, sleep, util,
    splice = [].splice;

  Request = require('request-promise-native');

  ({URL, URLSearchParams} = require('url'));

  Path = require('path');

  util = require('util');

  MD5 = require('md5.js');

  Property = require('./Property');

  CError = require('./CoinexError');

  HOST = 'https://api.coinex.com';

  V1 = new URL('v1', 'https://api.coinex.com');

  sleep = (secs = 10) => {
    return new Promise((resolve, reject) => {
      return setTimeout(() => {
        return resolve();
      }, secs * 1000);
    });
  };

  arrayFloat = function(arr) {
    if (typeof arr === 'string') {
      return parseFloat(arr);
    }
    return arr.map(function(element) {
      if (typeof element === 'string') {
        return arrayFloat(element);
      } else {
        return element;
      }
    });
  };

  dataFloat = function(obj) {
    var i, k, keys, len;
    keys = ['amount', 'avg_price', 'deal_amount', 'deal_fee', 'deal_money', 'left', 'maker_fee_rate', 'price', 'taker_fee_rate'];
    for (i = 0, len = keys.length; i < len; i++) {
      k = keys[i];
      obj[k] = parseFloat(obj[k]);
    }
    obj.create_time = new Date(obj.create_time * 1000);
    return obj;
  };

  Coinex = class Coinex extends Property {
    constructor(key, secret) {
      super();
      this.key = key;
      this.secret = secret;
    }

    get(...path) {
      var ref, search, uri;
      ref = path, [...path] = ref, [search] = splice.call(path, -1);
      uri = new URL(HOST);
      if (typeof search === 'object') {
        uri.search = new URLSearchParams(search);
      } else {
        path.push(search);
      }
      uri.pathname = Path.join('/v1', ...path);
      return Request({
        url: uri,
        json: true
      }).then(function(result) {
        if (result.code !== 0) {
          throw new CError(result.code, result.message);
        }
        return result.data;
      });
    }

    delete(...path) {
      var md5, params, ref, search, uri;
      ref = path, [...path] = ref, [search] = splice.call(path, -1);
      uri = new URL(HOST);
      uri.search = new URLSearchParams(search);
      uri.pathname = Path.join('/v1', ...path);
      uri.searchParams.set('access_id', this.key);
      uri.searchParams.set('tonce', new Date().valueOf());
      uri.searchParams.sort();
      uri.searchParams.set('secret_key', this.secret);
      md5 = new MD5();
      md5.update(uri.search.toString().substr(1)); // Lose the leading '?'
      uri.searchParams.delete('secret_key');
      params = {
        uri: uri,
        json: true,
        method: 'DELETE',
        headers: {
          authorization: md5.digest('hex').toUpperCase()
        }
      };
      return Request(params).then(function(result) {
        if (result.code !== 0) {
          throw new CError(result.code, result.message);
        }
        return result.data;
      });
    }

    getAuth(...path) {
      var md5, params, ref, search, uri;
      ref = path, [...path] = ref, [search] = splice.call(path, -1);
      uri = new URL(HOST);
      uri.search = new URLSearchParams(search);
      uri.pathname = Path.join('/v1', ...path);
      uri.searchParams.set('access_id', this.key);
      uri.searchParams.set('tonce', new Date().valueOf());
      uri.searchParams.sort();
      uri.searchParams.set('secret_key', this.secret);
      md5 = new MD5();
      md5.update(uri.search.toString().substr(1)); // Lose the leading '?'
      uri.searchParams.delete('secret_key');
      params = {
        uri: uri,
        json: true,
        method: 'GET',
        headers: {
          authorization: md5.digest('hex').toUpperCase()
        }
      };
      return Request(params).then(function(result) {
        if (result.code !== 0) {
          throw new CError(result.code, result.message);
        }
        return result.data;
      });
    }

    post(...path) {
      var md5, params, ref, search, uri;
      ref = path, [...path] = ref, [params] = splice.call(path, -1);
      uri = new URL(HOST);
      uri.pathname = Path.join('/v1', ...path);
      params.access_id = this.key;
      params.tonce = new Date().valueOf();
      search = new URLSearchParams(params);
      search.sort();
      search.set('secret_key', this.secret);
      md5 = new MD5();
      md5.update(search.toString());
      return Request({
        uri: uri,
        json: true,
        method: 'POST',
        body: params,
        headers: {
          authorization: md5.digest('hex').toUpperCase()
        }
      }).then(function(result) {
        if (result.code !== 0) {
          throw new CError(result.code, result.message);
        }
        return result.data;
      });
    }

    //#################################################################
    //# Market API
    //#################################################################
    list() {
      return this.get('market', 'list');
    }

    ticker(pair) {
      return this.get('market', 'ticker', {
        market: pair
      }).then((data) => {
        return data.ticker;
      });
    }

    tickerAll() {
      return this.get('market', 'ticker', 'all').then((data) => {
        return data.ticker;
      });
    }

    depth(pair, limit = 100, dp = 8) {
      var merge;
      merge = dp ? `0.${'0'.repeat(dp - 1)}1` : 0;
      return this.get('market', 'depth', {
        market: pair,
        merge: merge,
        limit: limit
      }).then(function(data) {
        data.asks = arrayFloat(data.asks);
        data.bids = arrayFloat(data.bids);
        return data;
      });
    }

    transactions(pair, lastID) {
      var params;
      params = {
        market: pair
      };
      if (lastID != null) {
        params.last_id = lastID;
      }
      return this.get('market', 'deals', params).then((data) => {
        var i, item, len, results;
        results = [];
        for (i = 0, len = data.length; i < len; i++) {
          item = data[i];
          results.push({
            amount: parseFloat(item.amount),
            date: new Date(item.date_ms),
            price: parseFloat(item.price),
            type: item.type,
            id: item.id
          });
        }
        return results;
      });
    }

    kline(pair, type = '1hour') {
      return this.get('market', 'kline', {
        market: pair,
        type: type
      }).then(function(data) {
        var i, item, len, results;
        results = [];
        for (i = 0, len = data.length; i < len; i++) {
          item = data[i];
          item[0] = new Date(item[0] * 1000);
          results.push(arrayFloat(item));
        }
        return results;
      });
    }

    //#################################################################
    //# Account API
    //#################################################################
    balance() {
      return this.getAuth('balance', {}).then((data) => {
        var k, v;
        for (k in data) {
          v = data[k];
          v.available = parseFloat(v.available);
          v.frozen = parseFloat(v.frozen);
        }
        return data;
      });
    }

    depositList() {
      return this.getAuth('balance/coin/deposit', {}).then((data) => {
        return data;
      });
    }

    depositList(pair) {
      var params;
      params = {
        coin_type: pair
      };
      return this.getAuth('balance/coin/deposit', params).then((data) => {
        return data;
      });
    }

    //#################################################################
    //# Trading API
    //#################################################################
    placeLimitOrder(pair, type, amount, price, sourceID) {
      var params;
      params = {
        market: pair,
        type: type,
        amount: amount.toString(),
        price: price.toString()
      };
      if (sourceID) {
        params.source_id = sourceID;
      }
      return this.post('order', 'limit', params).then(function(data) {
        return dataFloat(data);
      });
    }

    placeMarketOrder(pair, type, amount) {
      return this.post('order', 'market', {
        market: pair,
        type: type,
        amount: amount
      }).then(function(data) {
        return dataFloat(data);
      });
    }

    cancelOrder(pair, id) {
      return this.delete('order', 'pending', {
        market: pair,
        id: id
      }).then(function(data) {
        return dataFloat(data);
      });
    }

    pending(pair, page = 1, limit = 100) {
      return this.getAuth('order', 'pending', {
        market: pair,
        page: page,
        limit: limit
      }).then(function(data) {
        var i, len, order, ref;
        ref = data.data;
        for (i = 0, len = ref.length; i < len; i++) {
          order = ref[i];
          dataFloat(order);
        }
        return data;
      });
    }

    completed(pair, page = 1, limit = 100) {
      return this.getAuth('order', 'finished', {
        market: pair,
        page: page,
        limit: limit
      }).then(function(data) {
        var i, len, order, ref;
        ref = data.data;
        for (i = 0, len = ref.length; i < len; i++) {
          order = ref[i];
          dataFloat(order);
        }
        return data;
      });
    }

    orderStatus(pair, id) {
      return this.getAuth('order', {
        market: pair,
        id: id
      }).then(function(data) {
        return dataFloat(data);
      });
    }

    history(pair, page = 1, limit = 100) {
      return this.getAuth('order', 'user', 'deals', {
        market: pair,
        page: page,
        limit: limit
      }).then(function(data) {
        var i, item, len, ref;
        ref = data.data;
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          item.amount = parseFloat(item.amount);
          item.deal_money = parseFloat(item.deal_money);
          item.fee = parseFloat(item.fee);
          item.price = parseFloat(item.price);
          item.create_time = new Date(item.create_time * 1000);
        }
        return data;
      });
    }

  };

  module.exports = Coinex;

}).call(this);
